С учётом очень упрощенного API страховых компаний и сценария взаимодействия для интеграции core-app и osago-aggregator применим вариант точка-точка с с асинхронным взаимодействием. Точка-точка, т.к. характер взаимодействия - выполнение команды, "зарегистрируй заявку и получи предложения". В таком сценарии потребуется два топика: один на отправку запроса на действие и второй на ответ с данными. Такой сценарий взаимодействия и не требует отдельной БД для сервиса osago-aggregator по следующим причинам:
- заявка и ответ по ней приходит лишь один раз и больше не меняется. Если клиент хочет поменять условия или просто перезапросить страховку еще раз (вдруг что-то изменится в лучшую сторону для него), то это новая заявка
- сервис не учавствует во взаимодействии с пользователем напрямую, нет необходимости менять саму сущность заявки, тем более, что она "порождается" во внешнем сервисе
- брокер достаточно надежный инструмент для хранения информации, пока её не получит сервис core-app, настройками хранения сообщения мы можем обеспечить надежный вариант хранения. 
Очевидно, что синхронный подход работы в ОСАГО сценарии от UI пользователя до core-app не слишком удобен: долгое ожидание ответа, все заявки придут за один раз "по последнему" (что противоречит желанию бизнеса). Эти проблемы можно решить через полинг, но это сильно нагрузит систему. И так WebSocket`у быть. В предлагаемом решении на WebSocket "вешается" только ответы по предложением страховок. Остальные компоненты UI оставим синхронными без доработок.
core-app в нескольких экземплярах не возникнет ли коллизии при обработке? Решения глобальных два: это внешняя синхронизация или фильтрация сообщений по заранее спроектированному идентификатору. Последний вариант в нашем сценарии предпочтителен: он проще в реализации, а данных не так много. Для реализации на практике при отправке запроса от core-app к osago-aggregator`у необоходимо добавать в атрибуты сообщения индетификатор текущей инстанции, osago-aggregator при ответе будет добавлять instance id core-app в ответ, по которому можно будет отфильтровать.

Во взаимодействии osago-aggragator с API страховых компаний можно применить следующие паттерны для повышения надежности:
Timeout - если время ожидание превышает согласованное время (в нашем случае это будет чуть меньше 60 секунд, например, 55сек), то разрывать соединение и сообщать о неуспешности операции пользователю
Retry - если в допустимое окно были ответы от внешних API, но с неуспешным результатом, то продолжать попытки создать заявку и получить предложение.
Circuit Breaker - если внешние API страховой компании недоступно, то даже не пытаться отправлять запросы, а сразу обрабатывать операцию как неуспешную
Rate Limiter тоже стоит применить и вот с какой целью. Если кол-во запросов от нашего приложения может за DDoS`ить API страховой компании, то условно будут потеряны все предложения. Классическая реализация патерна тут не подойдет, необходимо более тонко подойти к реализаци, например, анализируя среднее время ответ от API. Если "видно", что ответы проседают (не проходят наше окно в 55 секунд), нужно уменьшить число подаваемых запросов. На практике части клиентам придется отправлять сообщение, что компания не доступна повторите попытку поздне.
